F# DU in C#
https://stackoverflow.com/questions/17254855/what-is-the-simplest-way-to-access-data-of-an-f-discriminated-union-type-in-c
https://stackoverflow.com/questions/23843142/f-discriminated-union-usage-from-c-sharp


1. Parse Query
2. Run Query via getIteratorEx: 
    - This Discriminated Union gets the TokenOccurrences collection for each Term.
    - Process query recursively with getIteratorEx function with Query (Disriminated Union) param, etc.
        to get TokenOccurrences collection and create TokenPostingList of type TokenPositon.
    - The TokenOccurrences collection is then used as the parameter to create TokenPostingList.
    - The TokenPostingList of TokenOccurrence is then returned.
    - Recurrsively repeat until all search tokens have been processed.
    - Filterby calls the relevant SimpleEnumeratorsEx methods to apply filter op and returns 
        TokenPostingList with filterd TokenPostions after running query.



#if ANDROID
                // Opening State for Windows or After Completion of PlayAudioRange
                if (CurrentState == "Paused" && PreviousState == "Buffering" ||
                    CurrentState == "Stopped" && PreviousState == "Buffering")
                {
                    await PlayAudioRange(timeSpanRange);
                }
                else if (CurrentState == "Playing" && PreviousState == "Paused" ||
                         CurrentState == "Playing" && PreviousState == "Buffering")
                {
                    await PauseAudio();
                    message = $"Pausing {pid} Timespan {timeSpanRange}";
                }
                else if (CurrentState == "Paused" && PreviousState == "Playing")
                {
                    await PlayAudio();
                    message = $"Resume Playing {pid} Timespan {timeSpanRange}";
                }
                else
                {
                    string msg = $"Current State = {CurrentState} Previous State = {PreviousState}";
                    throw new Exception("Uknown State: " + msg);
                }
#elif WINDOWS
                // Opening State for Windows
                if (CurrentState == "Paused" && PreviousState == "Opening" ||
                    CurrentState == "Paused" && PreviousState == "Stopped")
                {
                    await PlayAudioRange(timeSpanRange);
                }
                else if (CurrentState == "Playing" && PreviousState == "Paused" ||
                         CurrentState == "Playing" && PreviousState == "Buffering")
                {
                    await PauseAudio();
                    message = $"Pausing {pid} Timespan {timeSpanRange}";
                }
                else if (CurrentState == "Paused" && PreviousState == "Playing")
                {
                    await PlayAudio();
                    message = $"Resume Playing {pid} Timespan {timeSpanRange}";
                }
                else
                {
                    string msg = $"Current State = {CurrentState} Previous State = {PreviousState}";
                    throw new Exception("Uknown State: " + msg);
                }
#endif

/// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        async Task SetReferencePids()
        {
            try
            {
                await MainThread.InvokeOnMainThreadAsync(() =>
                {
                    if (!ShowReferencePids)
                    {
                        var count = Paragraphs.Count();
                        foreach (var paragraph in Paragraphs)
                        {
                            var seqId = paragraph.SeqId;
                            var pid = paragraph.Pid;
                            var spanName = "span_" + seqId.ToString("000");
                            var span = contentPage.FindByName(spanName) as Span;
                            var spanText = span.Text;
                            span.Text = "";
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                await Shell.Current.DisplayAlert("Error!", ex.Message, "OK");
                return;
            }
        }

//[RelayCommand]
        //async Task SetReferencePids()
        //{
        //    try
        //    {
        //        await MainThread.InvokeOnMainThreadAsync(() =>
        //        {
        //            var vte = contentPage.Content.GetVisualTreeDescendants();
        //            using (var enumerator = vte.GetEnumerator())
        //            {
        //                while (enumerator.MoveNext())
        //                {
        //                    var child = enumerator.Current;
        //                    if (child != null)
        //                    {
        //                        var childType = child.GetType().Name;
        //                        if (childType == "Label")
        //                        {
        //                            var lbl = child as Label;
        //                            var styleId = lbl.StyleId;
        //                            var spn = lbl.FindByName("SP" + styleId) as Span;
        //                            if (spn != null)
        //                            {
        //                                var spanText = spn.Text;
        //                                if (ShowReferencePids)
        //                                {
        //                                    spn.Text = spn.StyleId;
        //                                }
        //                                else
        //                                {
        //                                    spn.Text = "";
        //                                }
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //        });
        //    }
        //    catch (Exception ex)
        //    {
        //        await App.Current.MainPage.DisplayAlert("Exception raised =>", ex.Message, "Cancel");
        //        return;
        //    }
        //}


    public string GetState(MediaElementState mes)
    {
        string state = string.Empty;
        switch (mes)
        {
            case MediaElementState.None:
                state = "None";
                break;
            case MediaElementState.Opening:
                state = "Opening";
                break;
            case MediaElementState.Buffering:
                state = "Buffering";
                break;
            case MediaElementState.Playing:
                state = "Playing";
                break;
            case MediaElementState.Paused:
                state = "Paused";
                break;
            case MediaElementState.Stopped:
                state = "Stopped";
                break;
            case MediaElementState.Failed:
                state = "Failed";
                break;
        }
        return state;
    }


    

This is How we did it :

https://github.com/BhangeeF16/MAUI-DOT-NET/blob/main/SampleApp/MauiProgram.cs

In MauiProgram.cs > CreateMauiApp

#if WINDOWS
        builder.ConfigureLifecycleEvents(events =>
        {
            events.AddWindows(wndLifeCycleBuilder =>
            {
                wndLifeCycleBuilder.OnWindowCreated(window =>
                {
                    IntPtr nativeWindowHandle = WinRT.Interop.WindowNative.GetWindowHandle(window);
                    WindowId win32WindowsId = Win32Interop.GetWindowIdFromWindow(nativeWindowHandle);
                    AppWindow winuiAppWindow = AppWindow.GetFromWindowId(win32WindowsId);    
                    if(winuiAppWindow.Presenter is OverlappedPresenter p)
                    { 
                       p.Maximize();
                       //p.IsAlwaysOnTop=true;
                       p.IsResizable=false;
                       p.IsMaximizable = false;
                       p.IsMinimizable=false;
                    }                     
                    else
                    {
                        const int width = 1920;
                        const int height = 1080;
                        winuiAppWindow.MoveAndResize(new RectInt32(1920 / 2 - width / 2, 1080 / 2 - height / 2, width, height));                      
                    }                        
                });
            });
        });

    Since September 2022, it can be done with simpler way:
public partial class App : Application
{
    public App()
    {
        InitializeComponent();

        MainPage = new AppShell();    
    }

    protected override Window CreateWindow(IActivationState activationState)
    {
        Window window = base.CreateWindow(activationState);
        window.Activated += Window_Activated;
        return window;
    }

    private async void Window_Activated(object sender, EventArgs e)
    {
    #if WINDOWS
        const int DefaultWidth = 1024;
        const int DefaultHeight = 800;

        var window = sender as Window;

        // change window size.
        window.Width = DefaultWidth;
        window.Height = DefaultHeight;

        // give it some time to complete window resizing task.
        await window.Dispatcher.DispatchAsync(() => { });

        var disp = DeviceDisplay.Current.MainDisplayInfo;

        // move to screen center
        window.X = (disp.Width / disp.Density - window.Width) / 2;
        window.Y = (disp.Height / disp.Density - window.Height) / 2;
    #endif    
    }
}
Related ticket: https://github.com/dotnet/maui/pull/4942

If you only want to do this for the Desktop Platforms, then you can do something similar to @ToolmakerSteve but per-platform by overriding the OnLaunched function within the Platforms/Windows/App.xaml.cs for example.

using Microsoft.UI;
using Microsoft.UI.Windowing;
using Windows.Graphics;
using WinRT.Interop;
//...
protected override void OnLaunched(LaunchActivatedEventArgs args)
{
    base.OnLaunched(args);

    var currentWindow = Application.Windows[0].Handler.PlatformView;
    IntPtr _windowHandle = WindowNative.GetWindowHandle(currentWindow);
    var windowId = Win32Interop.GetWindowIdFromWindow(_windowHandle);

    AppWindow appWindow = AppWindow.GetFromWindowId(windowId);
    appWindow.Resize(new SizeInt32(350, 600));
}
These methods of resizing are still not ideal as it will flicker when it's changing window size. This is simply because of the time taken between OnLaunch being fired and the window being resized by native win32 API calls. However, moving it directly to the Platform-specific code is a bit more semantic.

Unlike the other answer we cannot get the Requested dimensions from client pages to use as our Window dimensions.

private async Task<string> GetFileSizeInBytes(long TotalBytes)        
{            
    if (TotalBytes = 1073741824) //Giga Bytes            
    {                
        Decimal FileSize = Decimal.Divide(TotalBytes, 1073741824);                
        return String.Format("{0:##.##} GB", FileSize); 
    }            
    else if (TotalBytes = 1048576) //Mega Bytes            
    {                
        Decimal FileSize = Decimal.Divide(TotalBytes, 1048576);                
        return String.Format("{0:##.##} MB", FileSize);            
    }            
    else if (TotalBytes = 1024) //Kilo Bytes            
    {                
        Decimal FileSize = Decimal.Divide(TotalBytes, 1024);                
        return String.Format("{0:##.##} KB", FileSize);            
    }            
    else if (TotalBytes  0 & TotalBytes              
    {                
        Decimal FileSize = TotalBytes;                
        return String.Format("{0:##.##} Bytes", FileSize);            
    }            
    else            
    {                
        return "0 Bytes";            
    }        
    
 }        
 
 <Border Style="{{StaticResource TitlesPageBorder}}"
                                            BackgroundColor="{AppThemeBinding Light={StaticResource LightBackground}, 
                                                                              Dark={StaticResource UBDarkBackground}}"
                                            StrokeShape="Rectangle"
                                            HorizontalOptions="FillAndExpand"
                                            VerticalOptions="FillAndExpand"
                                            Padding="10,10,10,0">

1>C:\Program Files\dotnet\sdk\8.0.101\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.RuntimeIdentifierInference.targets(251,5): warning NETSDK1201: For projects targeting .NET 8.0 and higher, specifying a RuntimeIdentifier will no longer produce a self contained app by default. To continue building self-contained apps, set the SelfContained property to true or use the --self-contained argument.